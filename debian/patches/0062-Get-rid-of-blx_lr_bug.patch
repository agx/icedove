From: Mike Hommey <mh+mozilla@glandium.org>
Date: Sat, 14 Aug 2010 10:09:11 +0200
Subject: Get rid of blx_lr_bug.

https://bugzilla.mozilla.org/show_bug.cgi?id=586262
---
 mozilla/js/src/nanojit/NativeARM.cpp |   37 +++++++++++-----------------------
 mozilla/js/src/nanojit/NativeARM.h   |    1 -
 mozilla/js/src/nanojit/avmplus.cpp   |    7 ------
 3 files changed, 12 insertions(+), 33 deletions(-)

diff --git a/mozilla/js/src/nanojit/NativeARM.cpp b/mozilla/js/src/nanojit/NativeARM.cpp
index cd48850..ba08eea 100644
--- a/mozilla/js/src/nanojit/NativeARM.cpp
+++ b/mozilla/js/src/nanojit/NativeARM.cpp
@@ -42,7 +42,6 @@
 
 #ifdef UNDER_CE
 #include <cmnintrin.h>
-extern "C" bool blx_lr_broken();
 #endif
 
 #if defined(AVMPLUS_LINUX)
@@ -463,11 +462,6 @@ Assembler::asm_eor_imm(Register rd, Register rn, int32_t imm, int stat /* =0 */)
 void
 Assembler::nInit(AvmCore*)
 {
-#ifdef UNDER_CE
-    blx_lr_bug = blx_lr_broken();
-#else
-    blx_lr_bug = 0;
-#endif
 }
 
 void Assembler::nBeginAssembly()
@@ -868,26 +862,17 @@ Assembler::asm_call(LInsp ins)
             outputf("        %p:", _nIns);
         )
 
-        // Direct call: on v5 and above (where the calling sequence doesn't
-        // corrupt LR until the actual branch instruction), we can avoid an
-        // interlock in the "long" branch sequence by manually loading the
-        // target address into LR ourselves before setting up the parameters
-        // in other registers.
         BranchWithLink((NIns*)call->_address);
     } else {
-        // Indirect call: we assign the address arg to LR since it's not
-        // used for regular arguments, and is otherwise scratch since it's
-        // clobberred by the call. On v4/v4T, where we have to manually do
-        // the equivalent of a BLX, move LR into IP before corrupting LR
-        // with the return address.
-        if (blx_lr_bug) {
-            // workaround for msft device emulator bug (blx lr emulated as no-op)
-            underrunProtect(8);
-            BLX(IP);
-            MOV(IP,LR);
-        } else {
-            BLX(LR);
-        }
+        // Indirect call: we assign the address arg to LR
+#ifdef UNDER_CE
+        // workaround for msft device emulator bug (blx lr emulated as no-op)
+        underrunProtect(8);
+        BLX(IP);
+        MOV(IP, LR);
+#else
+        BLX(LR);
+#endif
         asm_regarg(ARGSIZE_LO, ins->arg(--argc), LR);
     }
 
@@ -1550,9 +1535,11 @@ Assembler::BLX(Register addr, bool chk /* = true */)
     NanoAssert(ARM_ARCH >= 5);
 
     NanoAssert(IsGpReg(addr));
+#ifdef UNDER_CE
     // There is a bug in the WinCE device emulator which stops "BLX LR" from
     // working as expected. Assert that we never do that!
-    if (blx_lr_bug) { NanoAssert(addr != LR); }
+    NanoAssert(addr != LR);
+#endif
 
     if (chk) {
         underrunProtect(4);
diff --git a/mozilla/js/src/nanojit/NativeARM.h b/mozilla/js/src/nanojit/NativeARM.h
index 55b2e8e..ce03c0a 100644
--- a/mozilla/js/src/nanojit/NativeARM.h
+++ b/mozilla/js/src/nanojit/NativeARM.h
@@ -229,7 +229,6 @@ verbose_only( extern const char* shiftNames[]; )
     int *       _nSlot;                                                         \
     int *       _startingSlot;                                                  \
     int *       _nExitSlot;                                                     \
-    bool        blx_lr_bug;                                                     \
     int         max_out_args; /* bytes */                                      
 
 //nj_dprintf("jmp_l_n count=%d, nins=%X, %X = %X\n", (_c), nins, _nIns, ((intptr_t)(nins+(_c))-(intptr_t)_nIns - 4) );
diff --git a/mozilla/js/src/nanojit/avmplus.cpp b/mozilla/js/src/nanojit/avmplus.cpp
index ab84abd..f436c1e 100644
--- a/mozilla/js/src/nanojit/avmplus.cpp
+++ b/mozilla/js/src/nanojit/avmplus.cpp
@@ -45,13 +45,6 @@
     typedef void *maddr_ptr;
 #endif
 
-#if defined(AVMPLUS_ARM) && defined(UNDER_CE)
-extern "C" bool
-blx_lr_broken() {
-    return false;
-}
-#endif
-
 using namespace avmplus;
 
 Config AvmCore::config;
-- 
