From: Mike Hommey <mh@glandium.org>
Date: Fri, 5 Feb 2010 17:24:15 +0100
Subject: [PATCH] Force better nsAutoT{Ptr,}Array buffer alignment

This solves issues on sparc in a better way than the previous workaround that
missed some other failure cases.

https://bugzilla.mozilla.org/show_bug.cgi?id=448658
---
 mozilla/xpcom/glue/nsTArray.cpp  |    2 +-
 mozilla/xpcom/glue/nsTArray.h    |   21 ++++++++++++++++++---
 mozilla/xpcom/glue/nsTPtrArray.h |   15 ++++++++++++++-
 3 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/mozilla/xpcom/glue/nsTArray.cpp b/mozilla/xpcom/glue/nsTArray.cpp
index b594526..8156c74 100644
--- a/mozilla/xpcom/glue/nsTArray.cpp
+++ b/mozilla/xpcom/glue/nsTArray.cpp
@@ -41,7 +41,7 @@
 #include "nsXPCOM.h"
 #include "nsDebug.h"
 
-nsTArray_base::Header nsTArray_base::sEmptyHdr = { 0, 0, 0 };
+nsTArray_base::Header nsTArray_base::sEmptyHdr = { 0, 0, 0, 0 };
 
 nsTArray_base::nsTArray_base()
   : mHdr(&sEmptyHdr) {
diff --git a/mozilla/xpcom/glue/nsTArray.h b/mozilla/xpcom/glue/nsTArray.h
index c55ecff..8f5c621 100644
--- a/mozilla/xpcom/glue/nsTArray.h
+++ b/mozilla/xpcom/glue/nsTArray.h
@@ -138,7 +138,8 @@ class NS_COM_GLUE nsTArray_base {
     // We prefix mData with a structure of this type.  This is done to minimize
     // the size of the nsTArray object when it is empty.
     struct Header {
-      PRUint32 mLength;
+      PRUint32 mLength: 31;
+      PRUint32 mAdjustAlignment: 1;
       PRUint32 mCapacity : 31;
       PRUint32 mIsAutoArray : 1;
     };
@@ -152,7 +153,8 @@ class NS_COM_GLUE nsTArray_base {
     Header* GetAutoArrayBuffer() {
       NS_ASSERTION(IsAutoArray(), "Should be an auto array to call this");
 
-      return reinterpret_cast<Header*>(&mHdr + 1);
+      return reinterpret_cast<Header*>(reinterpret_cast<char *>(&mHdr) +
+          sizeof(nsTArray_base) + mHdr->mAdjustAlignment * sizeof(PRUint32));
     }
 
     // Returns true if this is an nsAutoTArray and it currently uses the
@@ -873,16 +875,29 @@ class nsAutoTArray : public nsTArray<E> {
     nsAutoTArray() {
       base_type::mHdr = reinterpret_cast<Header*>(&mAutoBuf);
       base_type::mHdr->mLength = 0;
+      base_type::mHdr->mAdjustAlignment = 0;
       base_type::mHdr->mCapacity = N;
       base_type::mHdr->mIsAutoArray = 1;
 
+      NS_ASSERTION(reinterpret_cast<char *>(&mAutoBuf) <=
+         reinterpret_cast<char *>(base_type::GetAutoArrayBuffer()) +
+         sizeof(PRUint32),
+         "nsAutoTArray doesn't support required alignment");
+
+      base_type::mHdr->mAdjustAlignment =
+         (reinterpret_cast<Header*>(&mAutoBuf) ==
+          base_type::GetAutoArrayBuffer()) ? 0 : 1;
+
       NS_ASSERTION(base_type::GetAutoArrayBuffer() ==
                    reinterpret_cast<Header*>(&mAutoBuf),
                    "GetAutoArrayBuffer needs to be fixed");
     }
 
   protected:
-    char mAutoBuf[sizeof(Header) + N * sizeof(elem_type)];
+    union {
+      char mAutoBuf[sizeof(Header) + N * sizeof(elem_type)];
+      PRUint64 dummy;
+    };
 };
 
 // specialization for N = 0. this makes the inheritance model easier for
diff --git a/mozilla/xpcom/glue/nsTPtrArray.h b/mozilla/xpcom/glue/nsTPtrArray.h
index afe3999..7e1cf3a 100755
--- a/mozilla/xpcom/glue/nsTPtrArray.h
+++ b/mozilla/xpcom/glue/nsTPtrArray.h
@@ -104,16 +104,29 @@ class nsAutoTPtrArray : public nsTPtrArray<E> {
     nsAutoTPtrArray() {
       base_type::mHdr = reinterpret_cast<Header*>(&mAutoBuf);
       base_type::mHdr->mLength = 0;
+      base_type::mHdr->mAdjustAlignment = 0;
       base_type::mHdr->mCapacity = N;
       base_type::mHdr->mIsAutoArray = 1;
 
+      NS_ASSERTION(reinterpret_cast<char *>(&mAutoBuf) <=
+         reinterpret_cast<char *>(base_type::GetAutoArrayBuffer()) +
+         sizeof(PRUint32),
+         "nsAutoTPtrArray doesn't support required alignment");
+
+      base_type::mHdr->mAdjustAlignment =
+         (reinterpret_cast<Header*>(&mAutoBuf) ==
+          base_type::GetAutoArrayBuffer()) ? 0 : 1;
+
       NS_ASSERTION(base_type::GetAutoArrayBuffer() ==
                    reinterpret_cast<Header*>(&mAutoBuf),
                    "GetAutoArrayBuffer needs to be fixed");
     }
 
   protected:
-    char mAutoBuf[sizeof(Header) + N * sizeof(elem_type)];
+    union {
+      char mAutoBuf[sizeof(Header) + N * sizeof(elem_type)];
+      elem_type dummy;
+    };
 };
 
 #endif  // nsTPtrArray_h__
-- 
