From: Luke Wagner <luke@mozilla.com>
Date: Wed, 24 Aug 2011 14:28:28 -0700
Subject: Bug 589735 - Allow static JS strings to be turned off; turn off on
 ia64 (r=igor)

---
 mozilla/js/src/jsgcinlines.h       |   12 ++++++
 mozilla/js/src/jsnum.cpp           |    2 +
 mozilla/js/src/jsstr.cpp           |    4 ++
 mozilla/js/src/jstracer.cpp        |    9 ++++-
 mozilla/js/src/jstracer.h          |    2 +
 mozilla/js/src/tracejit/Writer.cpp |    5 ++-
 mozilla/js/src/vm/String-inl.h     |   77 ++++++++++++++++++++++++++++++++++++
 mozilla/js/src/vm/String.h         |   17 ++++++-
 8 files changed, 123 insertions(+), 5 deletions(-)

diff --git a/mozilla/js/src/jsgcinlines.h b/mozilla/js/src/jsgcinlines.h
index d79cf37..7b15d0a 100644
--- a/mozilla/js/src/jsgcinlines.h
+++ b/mozilla/js/src/jsgcinlines.h
@@ -52,6 +52,7 @@
 inline bool
 JSAtom::isUnitString(const void *ptr)
 {
+#ifdef JS_HAS_STATIC_STRINGS
     jsuword delta = reinterpret_cast<jsuword>(ptr) -
                     reinterpret_cast<jsuword>(unitStaticTable);
     if (delta >= UNIT_STATIC_LIMIT * sizeof(JSString))
@@ -60,11 +61,15 @@ JSAtom::isUnitString(const void *ptr)
     /* If ptr points inside the static array, it must be well-aligned. */
     JS_ASSERT(delta % sizeof(JSString) == 0);
     return true;
+#else
+    return false;
+#endif
 }
 
 inline bool
 JSAtom::isLength2String(const void *ptr)
 {
+#ifdef JS_HAS_STATIC_STRINGS
     jsuword delta = reinterpret_cast<jsuword>(ptr) -
                     reinterpret_cast<jsuword>(length2StaticTable);
     if (delta >= NUM_SMALL_CHARS * NUM_SMALL_CHARS * sizeof(JSString))
@@ -73,11 +78,15 @@ JSAtom::isLength2String(const void *ptr)
     /* If ptr points inside the static array, it must be well-aligned. */
     JS_ASSERT(delta % sizeof(JSString) == 0);
     return true;
+#else
+    return false;
+#endif
 }
 
 inline bool
 JSAtom::isHundredString(const void *ptr)
 {
+#ifdef JS_HAS_STATIC_STRINGS
     jsuword delta = reinterpret_cast<jsuword>(ptr) -
                     reinterpret_cast<jsuword>(hundredStaticTable);
     if (delta >= NUM_HUNDRED_STATICS * sizeof(JSString))
@@ -86,6 +95,9 @@ JSAtom::isHundredString(const void *ptr)
     /* If ptr points inside the static array, it must be well-aligned. */
     JS_ASSERT(delta % sizeof(JSString) == 0);
     return true;
+#else
+    return false;
+#endif
 }
 
 inline bool
diff --git a/mozilla/js/src/jsnum.cpp b/mozilla/js/src/jsnum.cpp
index 4b99034..03e3fc1 100644
--- a/mozilla/js/src/jsnum.cpp
+++ b/mozilla/js/src/jsnum.cpp
@@ -1203,6 +1203,7 @@ js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
     if (JSDOUBLE_IS_INT32(d, &i)) {
         if (base == 10 && JSAtom::hasIntStatic(i))
             return &JSAtom::intStatic(i);
+#ifdef JS_HAS_STATIC_STRINGS
         if (jsuint(i) < jsuint(base)) {
             if (i < 10)
                 return &JSAtom::intStatic(i);
@@ -1210,6 +1211,7 @@ js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
             JS_ASSERT(JSAtom::hasUnitStatic(c));
             return &JSAtom::unitStatic(c);
         }
+#endif
 
         if (JSFlatString *str = c->dtoaCache.lookup(base, d))
             return str;
diff --git a/mozilla/js/src/jsstr.cpp b/mozilla/js/src/jsstr.cpp
index 185cc8d..34e045a 100644
--- a/mozilla/js/src/jsstr.cpp
+++ b/mozilla/js/src/jsstr.cpp
@@ -2878,6 +2878,8 @@ static JSFunctionSpec string_methods[] = {
     JS_FS_END
 };
 
+#ifdef JS_HAS_STATIC_STRINGS
+
 /*
  * Set up some tools to make it easier to generate large tables. After constant
  * folding, for each n, Rn(0) is the comma-separated list R(0), R(1), ..., R(2^n-1).
@@ -3072,6 +3074,8 @@ const JSString::Data *const JSAtom::intStaticTable[] = { R8(0) };
 #undef R3
 #undef R7
 
+#endif  /* defined(JS_HAS_STATIC_STRINGS) */
+
 JSBool
 js_String(JSContext *cx, uintN argc, Value *vp)
 {
diff --git a/mozilla/js/src/jstracer.cpp b/mozilla/js/src/jstracer.cpp
index 0cfe114..3223cb1 100644
--- a/mozilla/js/src/jstracer.cpp
+++ b/mozilla/js/src/jstracer.cpp
@@ -11469,6 +11469,7 @@ TraceRecorder::callNative(uintN argc, JSOp mode)
             }
             if (vp[1].isString()) {
                 JSString *str = vp[1].toString();
+#ifdef JS_HAS_STATIC_STRINGS
                 if (native == js_str_charAt) {
                     jsdouble i = vp[2].toNumber();
                     if (JSDOUBLE_IS_NaN(i))
@@ -11482,7 +11483,9 @@ TraceRecorder::callNative(uintN argc, JSOp mode)
                     set(&vp[0], char_ins);
                     pendingSpecializedNative = IGNORE_NATIVE_CALL_COMPLETE_CALLBACK;
                     return RECORD_CONTINUE;
-                } else if (native == js_str_charCodeAt) {
+                } else
+#endif
+                if (native == js_str_charCodeAt) {
                     jsdouble i = vp[2].toNumber();
                     if (JSDOUBLE_IS_NaN(i))
                       i = 0;
@@ -12837,6 +12840,7 @@ TraceRecorder::getCharCodeAt(JSString *str, LIns* str_ins, LIns* idx_ins, LIns**
 JS_STATIC_ASSERT(sizeof(JSString) == 16 || sizeof(JSString) == 32);
 
 
+#ifdef JS_HAS_STATIC_STRINGS
 JS_REQUIRES_STACK LIns*
 TraceRecorder::getUnitString(LIns* str_ins, LIns* idx_ins)
 {
@@ -12881,6 +12885,7 @@ TraceRecorder::getCharAt(JSString *str, LIns* str_ins, LIns* idx_ins, JSOp mode,
     }
     return RECORD_CONTINUE;
 }
+#endif
 
 // Typed array tracing depends on EXPANDED_LOADSTORE and F2I
 #if NJ_EXPANDED_LOADSTORE_SUPPORTED && NJ_F2I_SUPPORTED
@@ -12915,6 +12920,7 @@ TraceRecorder::record_JSOP_GETELEM()
     LIns* obj_ins = get(&lval);
     LIns* idx_ins = get(&idx);
 
+#ifdef JS_HAS_STATIC_STRINGS
     // Special case for array-like access of strings.
     if (lval.isString() && hasInt32Repr(idx)) {
         if (call)
@@ -12927,6 +12933,7 @@ TraceRecorder::record_JSOP_GETELEM()
         set(&lval, char_ins);
         return ARECORD_CONTINUE;
     }
+#endif
 
     if (lval.isPrimitive())
         RETURN_STOP_A("JSOP_GETLEM on a primitive");
diff --git a/mozilla/js/src/jstracer.h b/mozilla/js/src/jstracer.h
index 8d0ad36..74b529d 100644
--- a/mozilla/js/src/jstracer.h
+++ b/mozilla/js/src/jstracer.h
@@ -1398,10 +1398,12 @@ class TraceRecorder
     JS_REQUIRES_STACK RecordingStatus getCharCodeAt(JSString *str,
                                                     nanojit::LIns* str_ins, nanojit::LIns* idx_ins,
                                                     nanojit::LIns** out_ins);
+#ifdef JS_HAS_STATIC_STRINGS
     JS_REQUIRES_STACK nanojit::LIns* getUnitString(nanojit::LIns* str_ins, nanojit::LIns* idx_ins);
     JS_REQUIRES_STACK RecordingStatus getCharAt(JSString *str,
                                                 nanojit::LIns* str_ins, nanojit::LIns* idx_ins,
                                                 JSOp mode, nanojit::LIns** out_ins);
+#endif
 
     JS_REQUIRES_STACK RecordingStatus initOrSetPropertyByName(nanojit::LIns* obj_ins,
                                                               Value* idvalp, Value* rvalp,
diff --git a/mozilla/js/src/tracejit/Writer.cpp b/mozilla/js/src/tracejit/Writer.cpp
index e926fd3..f6c6b4b 100644
--- a/mozilla/js/src/tracejit/Writer.cpp
+++ b/mozilla/js/src/tracejit/Writer.cpp
@@ -250,7 +250,9 @@ couldBeObjectOrString(LIns *ins)
         // ins = andq ins_oprnd1, ins_oprnd2
         ret = true;
 #endif
-    } else if (ins->isop(LIR_addp) &&
+    }
+#ifdef JS_HAS_STATIC_STRINGS
+    else if (ins->isop(LIR_addp) &&
                ((ins->oprnd1()->isImmP() &&
                  (void *)ins->oprnd1()->immP() == JSAtom::unitStaticTable) ||
                 (ins->oprnd2()->isImmP() &&
@@ -262,6 +264,7 @@ couldBeObjectOrString(LIns *ins)
         // ins = addp JSString::unitStringTable, ...
         ret = true;
     }
+#endif
 
     return ret;
 }
diff --git a/mozilla/js/src/vm/String-inl.h b/mozilla/js/src/vm/String-inl.h
index 117b874..5feff39 100644
--- a/mozilla/js/src/vm/String-inl.h
+++ b/mozilla/js/src/vm/String-inl.h
@@ -193,6 +193,7 @@ JSExternalString::new_(JSContext *cx, const jschar *chars, size_t length, intN t
     return str;
 }
 
+#ifdef JS_HAS_STATIC_STRINGS
 inline bool
 JSAtom::fitsInSmallChar(jschar c)
 {
@@ -304,6 +305,82 @@ JSAtom::lookupStatic(const jschar *chars, size_t length)
     return NULL;
 }
 
+#else  /* defined(JS_HAS_STATIC_STRINGS) */
+
+inline bool
+JSAtom::fitsInSmallChar(jschar c)
+{
+    return false;
+}
+
+inline bool
+JSAtom::hasUnitStatic(jschar c)
+{
+    return false;
+}
+
+inline JSStaticAtom &
+JSAtom::unitStatic(jschar c)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline bool
+JSAtom::hasUintStatic(uint32 u)
+{
+    return false;
+}
+
+inline JSStaticAtom &
+JSAtom::uintStatic(uint32 u)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline bool
+JSAtom::hasIntStatic(int32 i)
+{
+    return false;
+}
+
+inline JSStaticAtom &
+JSAtom::intStatic(jsint i)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline JSLinearString *
+JSAtom::getUnitStringForElement(JSContext *cx, JSString *str, size_t index)
+{
+    JS_ASSERT(index < str->length());
+    return js_NewDependentString(cx, str, index, 1);
+}
+
+inline JSStaticAtom &
+JSAtom::length2Static(jschar c1, jschar c2)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+inline JSStaticAtom &
+JSAtom::length2Static(uint32 i)
+{
+    JS_NOT_REACHED("no static strings");
+    return *(JSStaticAtom *)NULL;
+}
+
+/* Get a static atomized string for chars if possible. */
+inline JSStaticAtom *
+JSAtom::lookupStatic(const jschar *chars, size_t length)
+{
+    return NULL;
+}
+#endif /* defined(JS_HAS_STATIC_STRINGS) */
+
 JS_ALWAYS_INLINE void
 JSString::finalize(JSContext *cx)
 {
diff --git a/mozilla/js/src/vm/String.h b/mozilla/js/src/vm/String.h
index 30b9c1e..67ead48 100644
--- a/mozilla/js/src/vm/String.h
+++ b/mozilla/js/src/vm/String.h
@@ -655,24 +655,35 @@ class JSExternalString : public JSFixedString
 
 JS_STATIC_ASSERT(sizeof(JSExternalString) == sizeof(JSString));
 
+#if !defined(__ia64__)
+/*
+ * Don't use static strings on ia64 since the compiler may put the static
+ * memory out of the acceptable 47-bit jsval pointer range.
+ */
+# define JS_HAS_STATIC_STRINGS
+#endif
+
 class JSAtom : public JSFixedString
 {
   public:
     /* Exposed only for jits. */
 
+#ifdef JS_HAS_STATIC_STRINGS
     static const size_t UNIT_STATIC_LIMIT   = 256U;
     static const size_t SMALL_CHAR_LIMIT    = 128U; /* Bigger chars cannot be in a length-2 string. */
     static const size_t NUM_SMALL_CHARS     = 64U;
     static const size_t INT_STATIC_LIMIT    = 256U;
     static const size_t NUM_HUNDRED_STATICS = 156U;
 
-#ifdef __SUNPRO_CC
-# pragma align 8 (__1cGJSAtomPunitStaticTable_, __1cGJSAtomSlength2StaticTable_, __1cGJSAtomShundredStaticTable_)
-#endif
+# ifdef __SUNPRO_CC
+#  pragma align 8 (__1cGJSAtomPunitStaticTable_, __1cGJSAtomSlength2StaticTable_, __1cGJSAtomShundredStaticTable_)
+# endif
+
     static const JSString::Data unitStaticTable[];
     static const JSString::Data length2StaticTable[];
     static const JSString::Data hundredStaticTable[];
     static const JSString::Data *const intStaticTable[];
+#endif
 
   private:
     /* Defined in jsgcinlines.h */
-- 
