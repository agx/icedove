From 72a639ed61fda577f6a74412bf5c845158003edb Mon Sep 17 00:00:00 2001
From: Aryeh Gregor <ayg@aryeh.name>
Date: Fri, 13 Jul 2012 09:31:15 +0300
Subject: Bug 771994 - Make nsRangeStore refcounted; r=ehsan,a=lsblakk

---
 editor/libeditor/base/nsSelectionState.cpp |  110 ++++++++++------------------
 editor/libeditor/base/nsSelectionState.h   |   50 +++++++++----
 editor/libeditor/html/nsHTMLEditRules.cpp  |   63 ++++++++--------
 editor/libeditor/html/nsHTMLEditRules.h    |    2 +-
 4 files changed, 112 insertions(+), 113 deletions(-)

diff --git a/mozilla/editor/libeditor/base/nsSelectionState.cpp b/mozilla/editor/libeditor/base/nsSelectionState.cpp
index c1dc68d..9de9581 100644
--- a/mozilla/editor/libeditor/base/nsSelectionState.cpp
+++ b/mozilla/editor/libeditor/base/nsSelectionState.cpp
@@ -59,15 +59,14 @@ nsSelectionState::~nsSelectionState()
 void
 nsSelectionState::DoTraverse(nsCycleCollectionTraversalCallback &cb)
 {
-  nsRangeStore *item;
-  for (PRInt32 i = 0, iEnd = mArray.Count(); i < iEnd; ++i)
+  for (PRUint32 i = 0, iEnd = mArray.Length(); i < iEnd; ++i)
   {
-    nsRangeStore *item = static_cast<nsRangeStore*>(mArray.ElementAt(i));
+    nsRangeStore* item = mArray[i];
     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
-                                       "selection state mArray[i]->startNode");
+                                       "selection state mArray[i].startNode");
     cb.NoteXPCOMChild(item->startNode);
     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
-                                       "selection state mArray[i]->endNode");
+                                       "selection state mArray[i].endNode");
     cb.NoteXPCOMChild(item->endNode);
   }
 }
@@ -76,9 +75,8 @@ nsresult
 nsSelectionState::SaveSelection(nsISelection *aSel)
 {
   if (!aSel) return NS_ERROR_NULL_POINTER;
-  PRInt32 i,rangeCount, arrayCount = mArray.Count();
+  PRInt32 i,rangeCount, arrayCount = mArray.Length();
   aSel->GetRangeCount(&rangeCount);
-  nsRangeStore *item;
   
   // if we need more items in the array, new them
   if (arrayCount<rangeCount)
@@ -86,8 +84,8 @@ nsSelectionState::SaveSelection(nsISelection *aSel)
     PRInt32 count = rangeCount-arrayCount;
     for (i=0; i<count; i++)
     {
-      item = new nsRangeStore;
-      mArray.AppendElement(item);
+      mArray.AppendElement();
+      mArray[i] = new nsRangeStore();
     }
   }
   
@@ -96,8 +94,6 @@ nsSelectionState::SaveSelection(nsISelection *aSel)
   {
     for (i = arrayCount-1; i >= rangeCount; i--)
     {
-      item = (nsRangeStore*)mArray.ElementAt(i);
-      delete item;
       mArray.RemoveElementAt(i);
     }
   }
@@ -106,11 +102,9 @@ nsSelectionState::SaveSelection(nsISelection *aSel)
   nsresult res = NS_OK;
   for (i=0; i<rangeCount; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
-    if (!item) return NS_ERROR_UNEXPECTED;
     nsCOMPtr<nsIDOMRange> range;
     res = aSel->GetRangeAt(i, getter_AddRefs(range));
-    item->StoreRange(range);
+    mArray[i]->StoreRange(range);
   }
   
   return res;
@@ -121,8 +115,7 @@ nsSelectionState::RestoreSelection(nsISelection *aSel)
 {
   if (!aSel) return NS_ERROR_NULL_POINTER;
   nsresult res;
-  PRInt32 i, arrayCount = mArray.Count();
-  nsRangeStore *item;
+  PRUint32 i, arrayCount = mArray.Length();
 
   // clear out selection
   aSel->RemoveAllRanges();
@@ -130,10 +123,8 @@ nsSelectionState::RestoreSelection(nsISelection *aSel)
   // set the selection ranges anew
   for (i=0; i<arrayCount; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
-    if (!item) return NS_ERROR_UNEXPECTED;
     nsCOMPtr<nsIDOMRange> range;
-    item->GetRange(address_of(range));
+    mArray[i]->GetRange(address_of(range));
     if (!range) return NS_ERROR_UNEXPECTED;
    
     res = aSel->AddRange(range);
@@ -146,12 +137,9 @@ nsSelectionState::RestoreSelection(nsISelection *aSel)
 PRBool
 nsSelectionState::IsCollapsed()
 {
-  if (1 != mArray.Count()) return PR_FALSE;
-  nsRangeStore *item;
-  item = (nsRangeStore*)mArray.ElementAt(0);
-  if (!item) return PR_FALSE;
+  if (1 != mArray.Length()) return PR_FALSE;
   nsCOMPtr<nsIDOMRange> range;
-  item->GetRange(address_of(range));
+  mArray[0]->GetRange(address_of(range));
   if (!range) return PR_FALSE;
   PRBool bIsCollapsed;
   range->GetCollapsed(&bIsCollapsed);
@@ -162,21 +150,15 @@ PRBool
 nsSelectionState::IsEqual(nsSelectionState *aSelState)
 {
   if (!aSelState) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, myCount = mArray.Count(), itsCount = aSelState->mArray.Count();
+  PRUint32 i, myCount = mArray.Length(), itsCount = aSelState->mArray.Length();
   if (myCount != itsCount) return PR_FALSE;
   if (myCount < 1) return PR_FALSE;
 
-  nsRangeStore *myItem, *itsItem;
-  
   for (i=0; i<myCount; i++)
   {
-    myItem = (nsRangeStore*)mArray.ElementAt(i);
-    itsItem = (nsRangeStore*)(aSelState->mArray.ElementAt(i));
-    if (!myItem || !itsItem) return PR_FALSE;
-    
     nsCOMPtr<nsIDOMRange> myRange, itsRange;
-    myItem->GetRange(address_of(myRange));
-    itsItem->GetRange(address_of(itsRange));
+    mArray[i]->GetRange(address_of(myRange));
+    aSelState->mArray[i]->GetRange(address_of(itsRange));
     if (!myRange || !itsRange) return PR_FALSE;
   
     PRInt16 compResult;
@@ -193,19 +175,13 @@ void
 nsSelectionState::MakeEmpty()
 {
   // free any items in the array
-  nsRangeStore *item;
-  for (PRInt32 i = mArray.Count()-1; i >= 0; --i)
-  {
-    item = (nsRangeStore*)mArray.ElementAt(i);
-    delete item;
-  }
   mArray.Clear();
 }
 
 PRBool   
 nsSelectionState::IsEmpty()
 {
-  return (mArray.Count() == 0);
+  return mArray.IsEmpty();
 }
 
 /***************************************************************************
@@ -223,7 +199,7 @@ void
 nsRangeUpdater::RegisterRangeItem(nsRangeStore *aRangeItem)
 {
   if (!aRangeItem) return;
-  if (mArray.IndexOf(aRangeItem) != -1)
+  if (mArray.Contains(aRangeItem))
   {
     NS_ERROR("tried to register an already registered range");
     return;  // don't register it again.  It would get doubly adjusted.
@@ -241,15 +217,12 @@ nsRangeUpdater::DropRangeItem(nsRangeStore *aRangeItem)
 nsresult 
 nsRangeUpdater::RegisterSelectionState(nsSelectionState &aSelState)
 {
-  PRInt32 i, theCount = aSelState.mArray.Count();
+  PRUint32 i, theCount = aSelState.mArray.Length();
   if (theCount < 1) return NS_ERROR_FAILURE;
 
-  nsRangeStore *item;
-  
   for (i=0; i<theCount; i++)
   {
-    item = (nsRangeStore*)aSelState.mArray.ElementAt(i);
-    RegisterRangeItem(item);
+    RegisterRangeItem(aSelState.mArray[i]);
   }
 
   return NS_OK;
@@ -258,15 +231,12 @@ nsRangeUpdater::RegisterSelectionState(nsSelectionState &aSelState)
 nsresult 
 nsRangeUpdater::DropSelectionState(nsSelectionState &aSelState)
 {
-  PRInt32 i, theCount = aSelState.mArray.Count();
+  PRUint32 i, theCount = aSelState.mArray.Length();
   if (theCount < 1) return NS_ERROR_FAILURE;
 
-  nsRangeStore *item;
-  
   for (i=0; i<theCount; i++)
   {
-    item = (nsRangeStore*)aSelState.mArray.ElementAt(i);
-    DropRangeItem(item);
+    DropRangeItem(aSelState.mArray[i]);
   }
 
   return NS_OK;
@@ -279,14 +249,14 @@ nsRangeUpdater::SelAdjCreateNode(nsIDOMNode *aParent, PRInt32 aPosition)
 {
   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
   if (!aParent) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
 
   nsRangeStore *item;
   
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if ((item->startNode.get() == aParent) && (item->startOffset > aPosition))
@@ -309,7 +279,7 @@ nsRangeUpdater::SelAdjDeleteNode(nsIDOMNode *aNode)
 {
   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
   if (!aNode) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
 
   nsCOMPtr<nsIDOMNode> parent;
@@ -322,7 +292,7 @@ nsRangeUpdater::SelAdjDeleteNode(nsIDOMNode *aNode)
   nsRangeStore *item;
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if ((item->startNode.get() == parent) && (item->startOffset > offset))
@@ -367,7 +337,7 @@ nsRangeUpdater::SelAdjSplitNode(nsIDOMNode *aOldRightNode, PRInt32 aOffset, nsID
 {
   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
   if (!aOldRightNode || !aNewLeftNode) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
 
   nsCOMPtr<nsIDOMNode> parent;
@@ -384,7 +354,7 @@ nsRangeUpdater::SelAdjSplitNode(nsIDOMNode *aOldRightNode, PRInt32 aOffset, nsID
   
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if (item->startNode.get() == aOldRightNode)
@@ -423,14 +393,14 @@ nsRangeUpdater::SelAdjJoinNodes(nsIDOMNode *aLeftNode,
 {
   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
   if (!aLeftNode || !aRightNode || !aParent) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
 
   nsRangeStore *item;
 
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if (item->startNode.get() == aParent)
@@ -493,16 +463,16 @@ nsRangeUpdater::SelAdjInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset
 {
   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
 
-  PRInt32 count = mArray.Count();
+  PRUint32 count = mArray.Length();
   if (!count) return NS_OK;
   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aTextNode));
   if (!node) return NS_ERROR_NULL_POINTER;
   
-  PRInt32 len=aString.Length(), i;
+  PRUint32 len=aString.Length(), i;
   nsRangeStore *item;
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if ((item->startNode.get() == node) && (item->startOffset > aOffset))
@@ -519,7 +489,7 @@ nsRangeUpdater::SelAdjDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset
 {
   if (mLock) return NS_OK;  // lock set by Will/DidReplaceParent, etc...
 
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
   nsRangeStore *item;
   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(aTextNode));
@@ -527,7 +497,7 @@ nsRangeUpdater::SelAdjDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset
   
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if ((item->startNode.get() == node) && (item->startOffset > aOffset))
@@ -561,14 +531,14 @@ nsRangeUpdater::DidReplaceContainer(nsIDOMNode *aOriginalNode, nsIDOMNode *aNewN
   mLock = PR_FALSE;
 
   if (!aOriginalNode || !aNewNode) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
 
   nsRangeStore *item;
   
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if (item->startNode.get() == aOriginalNode)
@@ -596,14 +566,14 @@ nsRangeUpdater::DidRemoveContainer(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt
   mLock = PR_FALSE;
 
   if (!aNode || !aParent) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
 
   nsRangeStore *item;
   
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     if (item->startNode.get() == aNode)
@@ -660,14 +630,14 @@ nsRangeUpdater::DidMoveNode(nsIDOMNode *aOldParent, PRInt32 aOldOffset, nsIDOMNo
   mLock = PR_FALSE;
 
   if (!aOldParent || !aNewParent) return NS_ERROR_NULL_POINTER;
-  PRInt32 i, count = mArray.Count();
+  PRUint32 i, count = mArray.Length();
   if (!count) return NS_OK;
 
   nsRangeStore *item;
   
   for (i=0; i<count; i++)
   {
-    item = (nsRangeStore*)mArray.ElementAt(i);
+    item = mArray[i];
     if (!item) return NS_ERROR_NULL_POINTER;
     
     // like a delete in aOldParent
diff --git a/mozilla/editor/libeditor/base/nsSelectionState.h b/mozilla/editor/libeditor/base/nsSelectionState.h
index 4341afe..4b6fa22 100644
--- a/mozilla/editor/libeditor/base/nsSelectionState.h
+++ b/mozilla/editor/libeditor/base/nsSelectionState.h
@@ -39,10 +39,11 @@
 #define __selectionstate_h__
 
 #include "nsCOMPtr.h"
-#include "nsVoidArray.h"
+#include "nsTArray.h"
 #include "nsIDOMNode.h"
 #include "nsIDOMRange.h"
 #include "nsCycleCollectionParticipant.h"
+#include "nsAutoPtr.h" // for nsRefPtr
 
 class nsIDOMCharacterData;
 class nsISelection;
@@ -60,7 +61,29 @@ struct nsRangeStore
   ~nsRangeStore();
   nsresult StoreRange(nsIDOMRange *aRange);
   nsresult GetRange(nsCOMPtr<nsIDOMRange> *outRange);
-        
+
+  NS_IMETHODIMP_(nsrefcnt) AddRef(void) {
+    NS_PRECONDITION(PRInt32(mRefCnt) >= 0, "illegal refcnt");
+    NS_ASSERT_OWNINGTHREAD(nsRangeStore);
+    ++mRefCnt;
+    NS_LOG_ADDREF(this, mRefCnt, "nsRangeStore", sizeof(*this));
+    return mRefCnt;
+  } 
+  NS_IMETHODIMP_(nsrefcnt) Release(void) {
+    NS_PRECONDITION(0 != mRefCnt, "dup release");
+    NS_ASSERT_OWNINGTHREAD(nsRangeStore);
+    --mRefCnt;
+    NS_LOG_RELEASE(this, mRefCnt, "nsRangeStore");
+    if (mRefCnt == 0) {
+      mRefCnt = 1; /* stabilize */
+      NS_DELETEXPCOM(this);
+      return 0;
+    }
+    return mRefCnt;
+  }
+  nsAutoRefCnt mRefCnt;
+  NS_DECL_OWNINGTHREAD
+
   nsCOMPtr<nsIDOMNode> startNode;
   PRInt32              startOffset;
   nsCOMPtr<nsIDOMNode> endNode;
@@ -85,7 +108,7 @@ class nsSelectionState
     void     MakeEmpty();
     PRBool   IsEmpty();
   protected:    
-    nsVoidArray mArray;
+    nsTArray<nsRefPtr<nsRangeStore> > mArray;
     
     friend class nsRangeUpdater;
 };
@@ -129,7 +152,7 @@ class nsRangeUpdater
     nsresult WillMoveNode();
     nsresult DidMoveNode(nsIDOMNode *aOldParent, PRInt32 aOldOffset, nsIDOMNode *aNewParent, PRInt32 aNewOffset);
   protected:    
-    nsVoidArray mArray;
+    nsTArray<nsRefPtr<nsRangeStore> > mArray;
     PRBool mLock;
 };
 
@@ -145,25 +168,26 @@ class NS_STACK_CLASS nsAutoTrackDOMPoint
     nsRangeUpdater &mRU;
     nsCOMPtr<nsIDOMNode> *mNode;
     PRInt32 *mOffset;
-    nsRangeStore mRangeItem;
+    nsRefPtr<nsRangeStore> mRangeItem;
   public:
     nsAutoTrackDOMPoint(nsRangeUpdater &aRangeUpdater, nsCOMPtr<nsIDOMNode> *aNode, PRInt32 *aOffset) :
     mRU(aRangeUpdater)
     ,mNode(aNode)
     ,mOffset(aOffset)
     {
-      mRangeItem.startNode = *mNode;
-      mRangeItem.endNode = *mNode;
-      mRangeItem.startOffset = *mOffset;
-      mRangeItem.endOffset = *mOffset;
-      mRU.RegisterRangeItem(&mRangeItem);
+      mRangeItem = new nsRangeStore();
+      mRangeItem->startNode = *mNode;
+      mRangeItem->endNode = *mNode;
+      mRangeItem->startOffset = *mOffset;
+      mRangeItem->endOffset = *mOffset;
+      mRU.RegisterRangeItem(mRangeItem);
     }
     
     ~nsAutoTrackDOMPoint()
     {
-      mRU.DropRangeItem(&mRangeItem);
-      *mNode  = mRangeItem.startNode;
-      *mOffset = mRangeItem.startOffset;
+      mRU.DropRangeItem(mRangeItem);
+      *mNode  = mRangeItem->startNode;
+      *mOffset = mRangeItem->startOffset;
     }
 };
 
diff --git a/mozilla/editor/libeditor/html/nsHTMLEditRules.cpp b/mozilla/editor/libeditor/html/nsHTMLEditRules.cpp
index 4028f57..079d467 100644
--- a/mozilla/editor/libeditor/html/nsHTMLEditRules.cpp
+++ b/mozilla/editor/libeditor/html/nsHTMLEditRules.cpp
@@ -84,6 +84,7 @@
 #include "nsFrameSelection.h"
 #include "nsIDOM3Node.h"
 #include "nsContentUtils.h"
+#include "nsTArray.h"
 
 //const static char* kMOZEditorBogusNodeAttr="MOZ_EDITOR_BOGUS_NODE";
 //const static char* kMOZEditorBogusNodeValue="TRUE";
@@ -219,6 +220,7 @@ mDocChangeRange(nsnull)
   mCachedStyles[16] = StyleCache(nsEditProperty::cssBackgroundColor, emptyString, emptyString);
   mCachedStyles[17] = StyleCache(nsEditProperty::sub, emptyString, emptyString);
   mCachedStyles[18] = StyleCache(nsEditProperty::sup, emptyString, emptyString);
+  mRangeItem = new nsRangeStore();
 }
 
 nsHTMLEditRules::~nsHTMLEditRules()
@@ -334,17 +336,17 @@ nsHTMLEditRules::BeforeEdit(PRInt32 action, nsIEditor::EDirection aDirection)
     PRInt32 selOffset;
     res = mHTMLEditor->GetStartNodeAndOffset(selection, address_of(selStartNode), &selOffset);
     if (NS_FAILED(res)) return res;
-    mRangeItem.startNode = selStartNode;
-    mRangeItem.startOffset = selOffset;
+    mRangeItem->startNode = selStartNode;
+    mRangeItem->startOffset = selOffset;
 
     // get the selection end location
     res = mHTMLEditor->GetEndNodeAndOffset(selection, address_of(selEndNode), &selOffset);
     if (NS_FAILED(res)) return res;
-    mRangeItem.endNode = selEndNode;
-    mRangeItem.endOffset = selOffset;
+    mRangeItem->endNode = selEndNode;
+    mRangeItem->endOffset = selOffset;
 
     // register this range with range updater to track this as we perturb the doc
-    (mHTMLEditor->mRangeUpdater).RegisterRangeItem(&mRangeItem);
+    (mHTMLEditor->mRangeUpdater).RegisterRangeItem(mRangeItem);
 
     // clear deletion state bool
     mDidDeleteSelection = PR_FALSE;
@@ -401,7 +403,7 @@ nsHTMLEditRules::AfterEdit(PRInt32 action, nsIEditor::EDirection aDirection)
     res = AfterEditInner(action, aDirection);
 
     // free up selectionState range item
-    (mHTMLEditor->mRangeUpdater).DropRangeItem(&mRangeItem);
+    (mHTMLEditor->mRangeUpdater).DropRangeItem(mRangeItem);
 
     /* After inserting text the cursor Bidi level must be set to the level of the inserted text.
      * This is difficult, because we cannot know what the level is until after the Bidi algorithm
@@ -515,11 +517,11 @@ nsHTMLEditRules::AfterEditInner(PRInt32 action, nsIEditor::EDirection aDirection
       if (NS_FAILED(res)) return res;
       
       // also do this for original selection endpoints. 
-      nsWSRunObject(mHTMLEditor, mRangeItem.startNode, mRangeItem.startOffset).AdjustWhitespace();
+      nsWSRunObject(mHTMLEditor, mRangeItem->startNode, mRangeItem->startOffset).AdjustWhitespace();
       // we only need to handle old selection endpoint if it was different from start
-      if ((mRangeItem.startNode != mRangeItem.endNode) || (mRangeItem.startOffset != mRangeItem.endOffset))
+      if ((mRangeItem->startNode != mRangeItem->endNode) || (mRangeItem->startOffset != mRangeItem->endOffset))
       {
-        nsWSRunObject(mHTMLEditor, mRangeItem.endNode, mRangeItem.endOffset).AdjustWhitespace();
+        nsWSRunObject(mHTMLEditor, mRangeItem->endNode, mRangeItem->endOffset).AdjustWhitespace();
       }
     }
     
@@ -557,7 +559,7 @@ nsHTMLEditRules::AfterEditInner(PRInt32 action, nsIEditor::EDirection aDirection
   }
 
   res = mHTMLEditor->HandleInlineSpellCheck(action, selection, 
-                                            mRangeItem.startNode, mRangeItem.startOffset,
+                                            mRangeItem->startNode, mRangeItem->startOffset,
                                             rangeStartParent, rangeStartOffset,
                                             rangeEndParent, rangeEndOffset);
   if (NS_FAILED(res)) 
@@ -5802,39 +5804,42 @@ nsHTMLEditRules::GetNodesForOperation(nsCOMArray<nsIDOMRange>& inArrayOfRanges,
   
   if (!aDontTouchContent)
   {
-    nsVoidArray rangeItemArray;
+    nsTArray<nsRefPtr<nsRangeStore> > rangeItemArray;
+    if (!rangeItemArray.AppendElements(rangeCount)) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
+
+    NS_ASSERTION(rangeCount == rangeItemArray.Length(), "How did that happen?");
+
     // first register ranges for special editor gravity
-    // XXXbz doesn't this leak all the nsRangeStore structs on error
-    // conditions??
     for (i = 0; i < (PRInt32)rangeCount; i++)
     {
       opRange = inArrayOfRanges[0];
-      nsRangeStore *item = new nsRangeStore();
-      if (!item) return NS_ERROR_NULL_POINTER;
-      item->StoreRange(opRange);
-      mHTMLEditor->mRangeUpdater.RegisterRangeItem(item);
-      rangeItemArray.AppendElement((void*)item);
+      rangeItemArray[i] = new nsRangeStore();
+      rangeItemArray[i]->StoreRange(opRange);
+      mHTMLEditor->mRangeUpdater.RegisterRangeItem(rangeItemArray[i]);
       inArrayOfRanges.RemoveObjectAt(0);
     }    
-    // now bust up inlines
-    for (i = rangeCount-1; i >= 0; i--)
+    // now bust up inlines.  Safe to start at rangeCount-1, since we
+    // asserted we have enough items above.
+    for (i = rangeCount-1; i >= 0 && NS_SUCCEEDED(res); i--)
     {
-      nsRangeStore *item = (nsRangeStore*)rangeItemArray.ElementAt(i);
-      res = BustUpInlinesAtRangeEndpoints(*item);
-      if (NS_FAILED(res)) return res;    
+      res = BustUpInlinesAtRangeEndpoints(*rangeItemArray[i]);
     } 
     // then unregister the ranges
     for (i = 0; i < rangeCount; i++)
     {
-      nsRangeStore *item = (nsRangeStore*)rangeItemArray.ElementAt(0);
-      if (!item) return NS_ERROR_NULL_POINTER;
-      rangeItemArray.RemoveElementAt(0);
+      nsRangeStore *item = rangeItemArray[i];
       mHTMLEditor->mRangeUpdater.DropRangeItem(item);
-      res = item->GetRange(address_of(opRange));
-      if (NS_FAILED(res)) return res;
-      delete item;
+      nsresult res2 = item->GetRange(address_of(opRange));
+      if (NS_FAILED(res2) && NS_SUCCEEDED(res)) {
+        // Remember the failure, but keep going so we make sure to unregister
+        // all our range items.
+        res = res2;
+      }
       inArrayOfRanges.AppendObject(opRange);
     }    
+    if (NS_FAILED(res)) return res;
   }
   // gather up a list of all the nodes
   for (i = 0; i < rangeCount; i++)
diff --git a/mozilla/editor/libeditor/html/nsHTMLEditRules.h b/mozilla/editor/libeditor/html/nsHTMLEditRules.h
index b302c19..5d256a1 100644
--- a/mozilla/editor/libeditor/html/nsHTMLEditRules.h
+++ b/mozilla/editor/libeditor/html/nsHTMLEditRules.h
@@ -312,7 +312,7 @@ protected:
   nsCOMPtr<nsIDOMRange>   mUtilRange;
   PRUint32                mJoinOffset;  // need to remember an int across willJoin/didJoin...
   nsCOMPtr<nsIDOMNode>    mNewBlock;
-  nsRangeStore            mRangeItem;
+  nsRefPtr<nsRangeStore>  mRangeItem;
   StyleCache              mCachedStyles[SIZE_STYLE_TABLE];
 };
 
-- 
1.7.10.4

